"""
PARALLEL COMPUTING SCALING DEMONSTRATION
Generated by AI for educational purposes.

Prompted / modified by Kyle Wilson. 7/28/2025.
Makes an interactive plot of theoretical parallel speedup via Amdahl's Law.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button
import matplotlib.patches as patches

# Set up the plotting style
plt.style.use('default')
plt.rcParams['figure.figsize'] = (12, 8)

class ParallelScalingDemo:
    def __init__(self):
        print("PARALLEL COMPUTING SCALING DEMONSTRATIONS")
        print("=" * 50)
        print("\nThis notebook demonstrates key concepts in parallel computing:")
        print("1. Amdahl's Law and strong scaling")
        print("2. The impact of serial bottlenecks on parallel performance\n")
    
    def amdahl_speedup(self, p_cores, f_serial):
        """
        Calculate speedup according to Amdahl's Law
        p_cores: number of processor cores
        f_serial: fraction of work that must be done serially (0 to 1)
        """
        return 1 / (f_serial + (1 - f_serial) / p_cores)
    
    def strong_scaling_demo_interactive(self):
        """Interactive matplotlib-based strong scaling demo"""
        print("\n=== INTERACTIVE STRONG SCALING DEMO ===")
        print("Use the sliders to adjust serial fraction and max cores")
        print("Close the plot window when done to continue\n")
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))
        plt.subplots_adjust(bottom=0.25)
        
        # Initial parameters
        initial_serial = 0.1
        initial_max_cores = 32
        
        # Create slider axes
        ax_serial = plt.axes([0.2, 0.1, 0.3, 0.03])
        ax_cores = plt.axes([0.2, 0.05, 0.3, 0.03])
        
        # Create sliders
        slider_serial = Slider(ax_serial, 'Serial Fraction', 0.0, 0.5, 
                              valinit=initial_serial, valfmt='%.3f')
        slider_cores = Slider(ax_cores, 'Max Cores', 4, 128, 
                             valinit=initial_max_cores, valfmt='%d')
        
        def update_plot(val=None):
            serial_frac = slider_serial.val
            max_cores = int(slider_cores.val)
            
            cores = np.arange(1, max_cores + 1)
            speedup = self.amdahl_speedup(cores, serial_frac)
            efficiency = speedup / cores
            
            # Clear and redraw plots
            ax1.clear()
            ax2.clear()
            
            # Speedup plot
            ax1.plot(cores, speedup, 'b-', linewidth=2, label=f'Serial fraction = {serial_frac:.3f}')
            ax1.plot(cores, cores, 'k--', alpha=0.5, label='Ideal speedup')
            if serial_frac > 0:
                ax1.axhline(y=1/serial_frac, color='r', linestyle=':', 
                           label=f'Theoretical max = {1/serial_frac:.1f}')
            ax1.set_xlabel('Number of Cores')
            ax1.set_ylabel('Speedup')
            ax1.set_title('Strong Scaling: Speedup vs Cores (Amdahl\'s Law)')
            ax1.grid(True, alpha=0.3)
            ax1.legend()
            ax1.set_xlim(1, max_cores)
            
            # Efficiency plot
            ax2.plot(cores, efficiency * 100, 'g-', linewidth=2)
            ax2.set_xlabel('Number of Cores')
            ax2.set_ylabel('Parallel Efficiency (%)')
            ax2.set_title('Parallel Efficiency vs Cores')
            ax2.grid(True, alpha=0.3)
            ax2.set_xlim(1, max_cores)
            ax2.set_ylim(0, 100)
            
            # Add text box with key results
            textstr = f'Results:\nSpeedup @ {max_cores} cores: {speedup[-1]:.2f}x\nEfficiency @ {max_cores} cores: {efficiency[-1]*100:.1f}%'
            if serial_frac > 0:
                textstr += f'\nTheoretical max: {1/serial_frac:.1f}x'
            
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
            ax2.text(0.02, 0.98, textstr, transform=ax2.transAxes, fontsize=10,
                    verticalalignment='top', bbox=props)
            
            plt.draw()
        
        # Connect sliders to update function
        slider_serial.on_changed(update_plot)
        slider_cores.on_changed(update_plot)
        
        # Initial plot
        update_plot()
        
        plt.show()
    



# Create the demo instance
demo = ParallelScalingDemo()

# Test if matplotlib interactive backend is working
print("Testing matplotlib backend...")
print(f"Current backend: {plt.get_backend()}")
print("If you see 'Agg', interactive plots may not work in your environment.\n")

# Run interactive demo
try:
    demo.strong_scaling_demo_interactive()
    print("\nInteractive demo completed successfully!")
except Exception as e:
    print(f"\nInteractive plot failed: {e}")
    print("You may need to enable interactive matplotlib backend.")

print("\n" + "="*60)
print("DISCUSSION QUESTIONS FOR STUDENTS:")
print("="*60)
print("""
1. What happens to speedup as the serial fraction increases?
   → Even small serial fractions (5-10%) dramatically limit scalability

2. Why does parallel efficiency decrease as we add more cores?
   → The serial portion becomes the bottleneck (Amdahl's Law)

3. What strategies can minimize the serial fraction in parallel algorithms?
   → Better algorithm design, reduce synchronization points

4. At what point does adding more cores become counterproductive?
   → When overhead costs exceed benefits from parallelization

5. How does this apply to real-world parallel programming?
   → Shows importance of identifying and minimizing serial bottlenecks

KEY TAKEAWAYS:
• Amdahl's Law shows the theoretical limit of parallel speedup
• Serial bottlenecks become dominant with many cores  
• Even small serial fractions (5-10%) dramatically limit scalability
• Parallel efficiency decreases as core count increases
• Focus on minimizing serial work for better parallel performance
""")
